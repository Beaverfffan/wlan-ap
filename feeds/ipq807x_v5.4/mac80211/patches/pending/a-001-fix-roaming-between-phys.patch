--- a/drivers/net/wireless/ath/ath11k/peer.c
+++ b/drivers/net/wireless/ath/ath11k/peer.c
@@ -93,6 +93,25 @@ struct ath11k_peer *ath11k_peer_find_by_
 	return NULL;
 }
 
+struct ath11k_peer *ath11k_peer_find_by_pdev_idx(struct ath11k_base *ab,
+							u8 pdev_idx, const u8 *addr)
+{
+	struct ath11k_peer *peer;
+
+	lockdep_assert_held(&ab->base_lock);
+
+	list_for_each_entry(peer, &ab->peers, list) {
+		if (peer->pdev_idx != pdev_idx)
+			continue;
+		if (!ether_addr_equal(peer->addr, addr))
+			continue;
+
+		return peer;
+	}
+
+	return NULL;
+}
+
 struct ath11k_peer *ath11k_peer_find_by_ast(struct ath11k_base *ab,
 					   int ast_hash)
 {
@@ -799,6 +816,21 @@ int ath11k_peer_delete(struct ath11k *ar
 	spin_lock_bh(&ar->ab->base_lock);
 
 	peer = ath11k_peer_find_by_addr(ar->ab, addr);
+	/* Check if the found peer is what we want to remove.
+	 * While the sta is transitioning to another band we may
+	 * have 2 peer with the same addr assigned to different
+	 * vdev_id. Make sure we are deleting the correct peer.
+	 */
+	if (peer && peer->vdev_id == vdev_id)
+		ath11k_peer_rhash_delete(ar->ab, peer);
+
+	/* Fallback to peer list search if the correct peer can't be found.
+	 * Skip the deletion of the peer from the rhash since it has already
+	 * been deleted in peer add.
+	 */
+	if (!peer)
+		peer = ath11k_peer_find(ar, vdev_id, addr);
+
 	if (peer) {
 #ifdef CPTCFG_ATH11K_NSS_SUPPORT
 		peer->delete_in_progress = true;
@@ -819,8 +851,8 @@ int ath11k_peer_delete(struct ath11k *ar
 				}
 			}
 #endif
-		ath11k_peer_rhash_delete(ar->ab, peer);
 	}
+
 	spin_unlock_bh(&ar->ab->base_lock);
 	mutex_unlock(&ar->ab->tbl_mtx_lock);
 #ifdef CPTCFG_ATH11K_NSS_SUPPORT
@@ -837,7 +869,6 @@ int ath11k_peer_delete(struct ath11k *ar
 	ret = ath11k_wait_for_peer_delete_done(ar, vdev_id, addr);
 	if (ret)
 		return ret;
-
 	ATH11K_MEMORY_STATS_DEC(ar->ab, per_peer_object,
 				sizeof(struct ath11k_peer));
 
@@ -867,13 +886,21 @@ int ath11k_peer_create(struct ath11k *ar
 		return -ENOBUFS;
 	}
 
+	mutex_lock(&ar->ab->tbl_mtx_lock);
 	spin_lock_bh(&ar->ab->base_lock);
-	peer = ath11k_peer_find_by_addr(ar->ab, param->peer_addr);
+	peer = ath11k_peer_find_by_pdev_idx(ar->ab, ar->pdev_idx, param->peer_addr);
 	if (peer) {
 		spin_unlock_bh(&ar->ab->base_lock);
+		mutex_unlock(&ar->ab->tbl_mtx_lock);
 		return -EINVAL;
 	}
+
+	peer = ath11k_peer_find_by_addr(ar->ab, param->peer_addr);
+	if (peer)
+		ath11k_peer_rhash_delete(ar->ab, peer);
+
 	spin_unlock_bh(&ar->ab->base_lock);
+	mutex_unlock(&ar->ab->tbl_mtx_lock);
 
 	ret = ath11k_wmi_send_peer_create_cmd(ar, param);
 	if (ret) {
