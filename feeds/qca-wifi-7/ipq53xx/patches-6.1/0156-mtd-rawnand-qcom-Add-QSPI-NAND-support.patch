From 3e76bf7bde84eec284141e1e0c8df41c0d0e4a9f Mon Sep 17 00:00:00 2001
From: Md Sadre Alam <quic_mdalam@quicinc.com>
Date: Fri, 17 Mar 2023 16:37:07 +0530
Subject: [PATCH 156/281] mtd: rawnand: qcom: Add QSPI NAND support

This change will add QSPI NAND support for IPQ9574.

Change-Id: I5456d1701fa7b98a4f2620462c310710a6fe8359
Signed-off-by: Md Sadre Alam <quic_mdalam@quicinc.com>
---
 drivers/mtd/nand/raw/nand_ids.c   |  57 ++
 drivers/mtd/nand/raw/qcom_nandc.c | 922 +++++++++++++++++++++++++++++-
 2 files changed, 958 insertions(+), 21 deletions(-)

diff --git a/drivers/mtd/nand/raw/nand_ids.c b/drivers/mtd/nand/raw/nand_ids.c
index dacc5529b3df..ebdd192cddd1 100644
--- a/drivers/mtd/nand/raw/nand_ids.c
+++ b/drivers/mtd/nand/raw/nand_ids.c
@@ -61,6 +61,63 @@ struct nand_flash_dev nand_flash_ids[] = {
 	{"TH58NVG3S0HBAI4 8G 3.3V 8-bit",
 		{ .id = {0x98, 0xd3, 0x91, 0x26, 0x76} },
 		  SZ_4K, SZ_1K, SZ_256K, 0, 5, 256, NAND_ECC_INFO(8, SZ_512)},
+	{"GD5F1GQ4RE9IG SPI NAND 1G 1.8V 4-bit",
+		{ .id = {0xc8, 0xc1} },
+		  SZ_2K, SZ_128, SZ_128K, 0, 2, 128, NAND_ECC_INFO(8, SZ_512) },
+	{"GD5F1GQ4RE9IH SPI NAND 1G 1.8V 4-bit",
+		{ .id = {0xc8, 0xc9} },
+		SZ_2K, SZ_128, SZ_128K, 0, 2, 64, NAND_ECC_INFO(4, SZ_512) },
+	{"GD5F2GQ5REYIH SPI NAND 2G 4-bit",
+		{ .id = {0xc8, 0x22} },
+		SZ_2K, SZ_256, SZ_128K, 0, 2, 64, NAND_ECC_INFO(4, SZ_512) },
+	{"MT29F1G01ABBFDWB-IT SPI NAND 1G 1.8V 4-bit",
+		{ .id = {0x2c, 0x15} },
+		SZ_2K, SZ_128, SZ_128K, 0, 2, 128, NAND_ECC_INFO(8, SZ_512) },
+	{"MX35UF4GE4AD-Z4I SPI NAND 1G 1.8V",
+		{ .id = {0xc2, 0xb7} },
+		SZ_4K, SZ_512, SZ_256K, 0, 2, 256, NAND_ECC_INFO(8, SZ_512)},
+
+	{"MX35UF2GE4AD-Z4I SPI NAND 2G 1.8V",
+		{ .id = {0xc2, 0xa6} },
+		SZ_2K, SZ_128, SZ_128K, 0, 2, 160, NAND_ECC_INFO(4, SZ_512)},
+
+	{"GD5F1GQ5REYIH SPI NAND 1G 1.8V",
+		{ .id = {0xc8, 0x21} },
+		SZ_2K, SZ_128, SZ_128K, 0, 2, 64, NAND_ECC_INFO(4, SZ_512)},
+	{"W25N01JW SPI NAND 1.8V 1G-BIT",
+		{ .id = {0xef, 0xbc} },
+		SZ_2K, SZ_128, SZ_128K, 0, 2, 64, NAND_ECC_INFO(4, SZ_512)},
+	{"GD5F1GQ5REYIG SPI NAND 1G",
+		{ .id = {0xc8, 0x41} },
+		SZ_2K, SZ_128, SZ_128K, 0, 2, 128, NAND_ECC_INFO(8, SZ_512)},
+	{"GD5F1GM7REYIG SPI NAND 1G-BIT",
+		{ .id = {0xc8, 0x81} },
+		SZ_2K, SZ_128, SZ_128K, 0, 2, 128, NAND_ECC_INFO(8, SZ_512)},
+	{"F50D1G41LB(2M) SPI NAND 1G 1.8V",
+		{ .id = {0xc8, 0x11} },
+		SZ_2K, SZ_128, SZ_128K, 0, 2, 64, NAND_ECC_INFO(4, SZ_512)},
+	{"GD5F4GQ6REYIHR SPI NAND 4G 1.8V",
+		{ .id = {0xc8, 0x25} },
+		SZ_2K, SZ_512, SZ_128K, 0, 2, 64, NAND_ECC_INFO(4, SZ_512)},
+	{"W25N02JWZEIF SPI NAND 2G 1.8V",
+		{ .id = {0xef, 0xbf} },
+		SZ_2K, SZ_256, SZ_128K, 0, 2, 64, NAND_ECC_INFO(4, SZ_512)},
+	{"MX35UF1GE4AC SPI NAND 1G 1.8V",
+		{ .id = {0xc2, 0x92} },
+		SZ_2K, SZ_128, SZ_128K, 0, 2, 64, NAND_ECC_INFO(4, SZ_512)},
+	{"F50D2G41KA-83YIG2V SPI NAND 2G 1.8V",
+		{ .id = {0xc8, 0x51} },
+		SZ_2K, SZ_256, SZ_128K, 0, 2, 128, NAND_ECC_INFO(8, SZ_512)},
+	{"DS35M1GA SPI NAND 1G 1.8V",
+		{ .id = {0xe5, 0x21} },
+		SZ_2K, SZ_128, SZ_128K, 0, 2, 64, NAND_ECC_INFO(4, SZ_512)},
+	{"GD5F2GQ5REYIG SPI NAND 2G",
+		{ .id = {0xc8, 0x42} },
+		SZ_2K, SZ_256, SZ_128K, 0, 2, 128, NAND_ECC_INFO(8, SZ_512)},
+
+	{"W25N01GWZEIG SPI NAND 1G 1.8V",
+		{ .id = {0xef, 0xba} },
+		SZ_2K, SZ_128, SZ_128K, 0, 2, 64, NAND_ECC_INFO(4, SZ_512)},
 
 	LEGACY_ID_NAND("NAND 4MiB 5V 8-bit",   0x6B, 4, SZ_8K, SP_OPTIONS),
 	LEGACY_ID_NAND("NAND 4MiB 3,3V 8-bit", 0xE3, 4, SZ_8K, SP_OPTIONS),
diff --git a/drivers/mtd/nand/raw/qcom_nandc.c b/drivers/mtd/nand/raw/qcom_nandc.c
index 198a44794d2d..0061376a2b91 100644
--- a/drivers/mtd/nand/raw/qcom_nandc.c
+++ b/drivers/mtd/nand/raw/qcom_nandc.c
@@ -36,6 +36,17 @@
 #define	NAND_DEV_CMD1			0xa4
 #define	NAND_DEV_CMD2			0xa8
 #define	NAND_DEV_CMD_VLD		0xac
+#define	NAND_DEV_CMD7			0xb0
+#define	NAND_DEV_CMD8			0xb4
+#define	NAND_DEV_CMD9			0xb8
+#define	NAND_FLASH_SPI_CFG		0xc0
+#define	NAND_SPI_NUM_ADDR_CYCLES	0xc4
+#define	NAND_SPI_BUSY_CHECK_WAIT_CNT	0xc8
+#define	NAND_DEV_CMD3			0xd0
+#define	NAND_DEV_CMD4			0xd4
+#define	NAND_DEV_CMD5			0xd8
+#define	NAND_DEV_CMD6			0xdc
+#
 #define	SFLASHC_BURST_CFG		0xe0
 #define	NAND_ERASED_CW_DETECT_CFG	0xe8
 #define	NAND_ERASED_CW_DETECT_STATUS	0xec
@@ -52,6 +63,9 @@
 #define	NAND_READ_LOCATION_LAST_CW_1	0xf44
 #define	NAND_READ_LOCATION_LAST_CW_2	0xf48
 #define	NAND_READ_LOCATION_LAST_CW_3	0xf4c
+#define	NAND_QSPI_MSTR_CONFIG		0xf60
+#define	NAND_FLASH_FEATURES		0xf64
+
 
 /* dummy register offsets, used by write_reg_dma */
 #define	NAND_DEV_CMD1_RESTORE		0xdead
@@ -71,6 +85,8 @@
 #define	FS_MPU_ERR			BIT(8)
 #define	FS_DEVICE_STS_ERR		BIT(16)
 #define	FS_DEVICE_WP			BIT(23)
+#define FS_TIMEOUT_ERR                  BIT(6)
+#define FLASH_ERROR                     (FS_OP_ERR | FS_MPU_ERR | FS_TIMEOUT_ERR)
 
 /* NAND_BUFFER_STATUS bits */
 #define	BS_UNCORRECTABLE_BIT		BIT(8)
@@ -159,6 +175,7 @@
 #define	OP_BLOCK_ERASE			0xa
 #define	OP_FETCH_ID			0xb
 #define	OP_RESET_DEVICE			0xd
+#define ACC_FEATURE                     0xe
 
 /* Default Value for NAND_DEV_CMD_VLD */
 #define NAND_DEV_CMD_VLD_VAL		(READ_START_VLD | WRITE_START_VLD | \
@@ -188,6 +205,61 @@
 #define	ECC_BCH_4BIT	BIT(2)
 #define	ECC_BCH_8BIT	BIT(3)
 
+#define LOAD_CLK_CNTR_INIT_EN   (1 << 28)
+#define CLK_CNTR_INIT_VAL_VEC   0x924
+#define FEA_STATUS_DEV_ADDR     0xc0
+#define SPI_CFG (1 << 0)
+
+/* CMD register value for qspi nand */
+#define	CMD0_VAL	0x1080D8D8
+#define	CMD1_VAL	0xF00F3000
+#define	CMD2_VAL	0xF0FF709F
+#define	CMD3_VAL	0x3F310015
+#define	CMD3_MASK	0xfff0ffff
+#define	CMD7_VAL	0x04061F0F
+#define	CMD_VLD_VAL	0xd
+#define	SPI_NUM_ADDR	0xDA4DB
+#define	WAIT_CNT	0x10
+
+/*
+ * SPI Nand flash device ID's
+ */
+#define	SPI_FLASH_MICRON_ID		0x2c
+#define	SPI_FLASH_ESMT_DEVICE_ID	0x11
+#define	SPI_FLASH_WINBOND_ID		0xef
+#define	SPI_WINBOND_DEVICE_1		0xba
+#define	SPI_FLASH_GIGA_ID		0xc8
+
+/*
+ * Serial NAND flash commands
+ */
+#define	NAND_CMD_READID_SERIAL		0x9F
+#define	NAND_CMD_ERASE_SERIAL		0xd8
+#define	NAND_CMD_SET_FEATURE_SERIAL	0x1F
+#define	NAND_CMD_GET_FEATURE_SERIAL	0x0F
+#define	SPI_FLASH_FEATURE_REG		0xB0
+
+/*
+ * Serial NAND flash status register bits
+ */
+#define	SPI_FLASH_QUAD_MODE		0x1
+#define	SPI_NAND_BUF_BIT(x)		(1 << x)
+
+/* QSPI NAND CMD reg bits value */
+#define	SPI_WP		(1 << 28)
+#define	SPI_HOLD	(1 << 27)
+#define	SPI_TRANSFER_MODE_x1	(1 << 29)
+#define	SPI_TRANSFER_MODE_x4	(3 << 29)
+#define	QPIC_SET_FEATURE	(1 << 31)
+#define QPIC_v2_0	0x2
+#define FEEDBACK_CLK_EN	(1 << 4)
+#define MAX_TRAINING_BLK	8
+#define TOTAL_NUM_PHASE	7
+#define	AUTO_STS_VAL	0x000B000B
+#define	PAGE_SCOPE_READ	(1 << 23)
+#define	MAX_STATUS_REG	12
+#define IO_MACRO_50_MHZ	50000000
+
 #define nandc_set_read_loc_first(chip, reg, cw_offset, read_size, is_last_read_loc)	\
 nandc_set_reg(chip, reg,			\
 	      ((cw_offset) << READ_LOCATION_OFFSET) |		\
@@ -216,6 +288,7 @@ nandc_set_reg(chip, reg,			\
 #define QPIC_PER_CW_CMD_ELEMENTS	32
 #define QPIC_PER_CW_CMD_SGL		32
 #define QPIC_PER_CW_DATA_SGL		8
+#define QPIC_PER_CW_STS_SGL             8
 
 #define QPIC_NAND_COMPLETION_TIMEOUT	msecs_to_jiffies(2000)
 
@@ -235,6 +308,16 @@ nandc_set_reg(chip, reg,			\
  */
 #define NAND_ERASED_CW_SET		BIT(4)
 
+/*
+ * An array holding the fixed pattern
+ */
+static const u32 qspi_training_block_64[] = {
+	0x0F0F0F0F, 0x0F0F0F0F, 0x0F0F0F0F, 0x0F0F0F0F,
+	0x0F0F0F0F, 0x0F0F0F0F, 0x0F0F0F0F, 0x0F0F0F0F,
+	0x0F0F0F0F, 0x0F0F0F0F, 0x0F0F0F0F, 0x0F0F0F0F,
+	0x0F0F0F0F, 0x0F0F0F0F, 0x0F0F0F0F, 0x0F0F0F0F,
+};
+
 /*
  * This data type corresponds to the BAM transaction which will be used for all
  * NAND transfers.
@@ -261,6 +344,7 @@ struct bam_transaction {
 	struct bam_cmd_element *bam_ce;
 	struct scatterlist *cmd_sgl;
 	struct scatterlist *data_sgl;
+	struct scatterlist *sts_sgl;
 	struct dma_async_tx_descriptor *last_data_desc;
 	struct dma_async_tx_descriptor *last_cmd_desc;
 	struct completion txn_done;
@@ -272,6 +356,8 @@ struct bam_transaction {
 	u32 tx_sgl_start;
 	u32 rx_sgl_pos;
 	u32 rx_sgl_start;
+	u32 sts_sgl_pos;
+	u32 sts_sgl_start;
 	bool wait_second_completion;
 };
 
@@ -333,9 +419,17 @@ struct nandc_regs {
 	__le32 read_location_last1;
 	__le32 read_location_last2;
 	__le32 read_location_last3;
+	__le32 flash_feature;
+	__le32 spi_cfg;
+	__le32 num_addr_cycle;
+	__le32 busy_wait_cnt;
+	__le32 mstr_cfg;
+
 
 	__le32 erased_cw_detect_cfg_clr;
 	__le32 erased_cw_detect_cfg_set;
+	__le32 auto_sts_en;
+
 };
 
 /*
@@ -390,6 +484,7 @@ struct qcom_nand_controller {
 
 	struct clk *core_clk;
 	struct clk *aon_clk;
+	struct clk *iomacro_clk;
 
 	struct nandc_regs *regs;
 	struct bam_transaction *bam_txn;
@@ -405,6 +500,7 @@ struct qcom_nand_controller {
 			struct dma_chan *tx_chan;
 			struct dma_chan *rx_chan;
 			struct dma_chan *cmd_chan;
+			struct dma_chan *sts_chan;
 		};
 
 		/* will be used only by EBI2 for ADM DMA */
@@ -432,6 +528,8 @@ struct qcom_nand_controller {
 	int reg_read_pos;
 
 	u32 cmd1, vld;
+	__le32 *status_buf;
+	int sts_buf_size;
 };
 
 /*
@@ -512,6 +610,8 @@ struct qcom_nand_host {
 	bool codeword_fixup;
 	bool use_ecc;
 	bool bch_enabled;
+	bool quad_mode;
+	bool check_qe_bit;
 };
 
 /*
@@ -529,8 +629,12 @@ struct qcom_nandc_props {
 	u32 dev_cmd_reg_start;
 	bool is_bam;
 	bool is_qpic;
+	bool is_serial_nand;
 	bool qpic_v2;
 	bool use_codeword_fixup;
+	bool is_serial_training;
+	bool quad_mode;
+	bool page_scope;
 };
 
 /* Frees the BAM transaction memory */
@@ -555,6 +659,8 @@ alloc_bam_transaction(struct qcom_nand_controller *nandc)
 		((sizeof(*bam_txn->bam_ce) * QPIC_PER_CW_CMD_ELEMENTS) +
 		(sizeof(*bam_txn->cmd_sgl) * QPIC_PER_CW_CMD_SGL) +
 		(sizeof(*bam_txn->data_sgl) * QPIC_PER_CW_DATA_SGL));
+	if (nandc->props->qpic_v2)
+		bam_txn_size += sizeof(*bam_txn->sts_sgl) * QPIC_PER_CW_STS_SGL * num_cw;
 
 	bam_txn_buf = devm_kzalloc(nandc->dev, bam_txn_size, GFP_KERNEL);
 	if (!bam_txn_buf)
@@ -573,6 +679,12 @@ alloc_bam_transaction(struct qcom_nand_controller *nandc)
 
 	bam_txn->data_sgl = bam_txn_buf;
 
+	if (nandc->props->qpic_v2) {
+		bam_txn_buf +=
+			sizeof(*bam_txn->data_sgl) * QPIC_PER_CW_DATA_SGL * num_cw;
+		bam_txn->sts_sgl = bam_txn_buf;
+	}
+
 	init_completion(&bam_txn->txn_done);
 
 	return bam_txn;
@@ -602,6 +714,13 @@ static void clear_bam_transaction(struct qcom_nand_controller *nandc)
 	sg_init_table(bam_txn->data_sgl, nandc->max_cwperpage *
 		      QPIC_PER_CW_DATA_SGL);
 
+	if (nandc->props->qpic_v2) {
+		bam_txn->sts_sgl_pos = 0;
+		bam_txn->sts_sgl_start = 0;
+		sg_init_table(bam_txn->sts_sgl, nandc->max_cwperpage *
+			      QPIC_PER_CW_STS_SGL);
+	}
+
 	reinit_completion(&bam_txn->txn_done);
 }
 
@@ -685,6 +804,8 @@ static __le32 *offset_to_nandc_reg(struct nandc_regs *regs, int offset)
 		return &regs->cfg1;
 	case NAND_DEV0_ECC_CFG:
 		return &regs->ecc_bch_cfg;
+	case NAND_AUTO_STATUS_EN:
+		return &regs->auto_sts_en;
 	case NAND_READ_STATUS:
 		return &regs->clrreadstatus;
 	case NAND_DEV_CMD1:
@@ -713,6 +834,16 @@ static __le32 *offset_to_nandc_reg(struct nandc_regs *regs, int offset)
 		return &regs->read_location_last2;
 	case NAND_READ_LOCATION_LAST_CW_3:
 		return &regs->read_location_last3;
+	case NAND_FLASH_SPI_CFG:
+		return &regs->spi_cfg;
+	case NAND_SPI_NUM_ADDR_CYCLES:
+		return &regs->num_addr_cycle;
+	case NAND_SPI_BUSY_CHECK_WAIT_CNT:
+		return &regs->busy_wait_cnt;
+	case NAND_QSPI_MSTR_CONFIG:
+		return &regs->mstr_cfg;
+	case NAND_FLASH_FEATURES:
+		return &regs->flash_feature;
 	default:
 		return NULL;
 	}
@@ -784,13 +915,26 @@ static void update_rw_regs(struct qcom_nand_host *host, int num_cw, bool read, i
 	u32 cmd, cfg0, cfg1, ecc_bch_cfg;
 	struct qcom_nand_controller *nandc = get_qcom_nand_controller(chip);
 
-	if (read) {
-		if (host->use_ecc)
-			cmd = OP_PAGE_READ_WITH_ECC | PAGE_ACC | LAST_PAGE;
+	cmd = (PAGE_ACC | LAST_PAGE);
+
+	if (nandc->props->is_serial_nand) {
+		if (nandc->props->quad_mode && host->quad_mode)
+			cmd |= SPI_TRANSFER_MODE_x4;
 		else
-			cmd = OP_PAGE_READ | PAGE_ACC | LAST_PAGE;
+			cmd |= SPI_TRANSFER_MODE_x1;
+		cmd |= (SPI_WP | SPI_HOLD);
+	}
+
+	if (read) {
+		if (host->use_ecc) {
+			cmd |= OP_PAGE_READ_WITH_ECC;
+			if (nandc->props->qpic_v2 && nandc->props->page_scope)
+				cmd |= PAGE_SCOPE_READ;
+		} else {
+			cmd |= OP_PAGE_READ;
+		}
 	} else {
-		cmd = OP_PROGRAM_PAGE | PAGE_ACC | LAST_PAGE;
+		cmd |= OP_PROGRAM_PAGE;
 	}
 
 	if (host->use_ecc) {
@@ -811,6 +955,8 @@ static void update_rw_regs(struct qcom_nand_host *host, int num_cw, bool read, i
 	nandc_set_reg(chip, NAND_DEV0_CFG0, cfg0);
 	nandc_set_reg(chip, NAND_DEV0_CFG1, cfg1);
 	nandc_set_reg(chip, NAND_DEV0_ECC_CFG, ecc_bch_cfg);
+	if (nandc->props->qpic_v2 && nandc->props->page_scope)
+		nandc_set_reg(chip, NAND_AUTO_STATUS_EN, AUTO_STS_VAL);
 	if (!nandc->props->qpic_v2)
 		nandc_set_reg(chip, NAND_EBI2_ECC_BUF_CFG, host->ecc_buf_cfg);
 	nandc_set_reg(chip, NAND_FLASH_STATUS, host->clrflashstatus);
@@ -855,6 +1001,12 @@ static int prepare_bam_async_desc(struct qcom_nand_controller *nandc,
 		bam_txn->tx_sgl_start = bam_txn->tx_sgl_pos;
 		dir_eng = DMA_MEM_TO_DEV;
 		desc->dir = DMA_TO_DEVICE;
+	} else if (nandc->props->qpic_v2 && chan == nandc->sts_chan) {
+		sgl = &bam_txn->sts_sgl[bam_txn->sts_sgl_start];
+		sgl_cnt = bam_txn->sts_sgl_pos - bam_txn->sts_sgl_start;
+		bam_txn->sts_sgl_start = bam_txn->sts_sgl_pos;
+		dir_eng = DMA_DEV_TO_MEM;
+		desc->dir = DMA_FROM_DEVICE;
 	} else {
 		sgl = &bam_txn->data_sgl[bam_txn->rx_sgl_start];
 		sgl_cnt = bam_txn->rx_sgl_pos - bam_txn->rx_sgl_start;
@@ -1146,6 +1298,27 @@ static int write_reg_dma(struct qcom_nand_controller *nandc, int first,
 				 num_regs * sizeof(u32), flow_control);
 }
 
+/*
+ * read_status_data_dma: prepares a DMA descriptor to transfer status from the
+ * 			 controller's status registers to buffer 'vaddr'
+ *
+ * @reg_off:            offset within the controller's data buffer
+ * @vaddr:              virtual address of the buffer we want to write to
+ * @size:               DMA transaction size in bytes
+ * @flags:              flags to control DMA descriptor preparation
+ */
+static int read_status_data_dma(struct qcom_nand_controller *nandc, int reg_off,
+		const u8 *vaddr, int size, unsigned int flags)
+{
+	struct bam_transaction *bam_txn = nandc->bam_txn;
+
+	sg_set_buf(&bam_txn->sts_sgl[bam_txn->sts_sgl_pos],
+			vaddr, size);
+	bam_txn->sts_sgl_pos++;
+
+	return 0;
+}
+
 /*
  * read_data_dma:	prepares a DMA descriptor to transfer data from the
  *			controller's internal buffer to the buffer 'vaddr'
@@ -1218,13 +1391,20 @@ config_nand_cw_read(struct nand_chip *chip, bool use_ecc, int cw)
 		write_reg_dma(nandc, reg, 4, NAND_BAM_NEXT_SGL);
 
 	write_reg_dma(nandc, NAND_FLASH_CMD, 1, NAND_BAM_NEXT_SGL);
-	write_reg_dma(nandc, NAND_EXEC_CMD, 1, NAND_BAM_NEXT_SGL);
 
 	if (use_ecc) {
-		read_reg_dma(nandc, NAND_FLASH_STATUS, 2, 0);
-		read_reg_dma(nandc, NAND_ERASED_CW_DETECT_STATUS, 1,
-			     NAND_BAM_NEXT_SGL);
+		if (nandc->props->qpic_v2 && nandc->props->page_scope) {
+			write_reg_dma(nandc, NAND_AUTO_STATUS_EN, 1, NAND_BAM_NEXT_SGL);
+			if (qcom_nandc_is_last_cw(ecc, cw))
+				write_reg_dma(nandc, NAND_EXEC_CMD, 1, NAND_BAM_NEXT_SGL);
+		} else {
+			write_reg_dma(nandc, NAND_EXEC_CMD, 1, NAND_BAM_NEXT_SGL);
+			read_reg_dma(nandc, NAND_FLASH_STATUS, 2, 0);
+			read_reg_dma(nandc, NAND_ERASED_CW_DETECT_STATUS, 1,
+			       NAND_BAM_NEXT_SGL);
+		}
 	} else {
+		write_reg_dma(nandc, NAND_EXEC_CMD, 1, NAND_BAM_NEXT_SGL);
 		read_reg_dma(nandc, NAND_FLASH_STATUS, 1, NAND_BAM_NEXT_SGL);
 	}
 }
@@ -1357,11 +1537,17 @@ static int erase_block(struct qcom_nand_host *host, int page_addr)
 {
 	struct nand_chip *chip = &host->chip;
 	struct qcom_nand_controller *nandc = get_qcom_nand_controller(chip);
+	u32 ers_cmd = OP_BLOCK_ERASE | PAGE_ACC | LAST_PAGE;
+	u32 addr1 = 0x0;
 
-	nandc_set_reg(chip, NAND_FLASH_CMD,
-		      OP_BLOCK_ERASE | PAGE_ACC | LAST_PAGE);
+	if (nandc->props->is_serial_nand) {
+		ers_cmd |= (SPI_WP | SPI_HOLD | SPI_TRANSFER_MODE_x1);
+		addr1 = (page_addr >> 16) & 0xffff;
+		page_addr <<= 16;
+	}
+	nandc_set_reg(chip, NAND_FLASH_CMD, ers_cmd);
 	nandc_set_reg(chip, NAND_ADDR0, page_addr);
-	nandc_set_reg(chip, NAND_ADDR1, 0);
+	nandc_set_reg(chip, NAND_ADDR1, addr1);
 	nandc_set_reg(chip, NAND_DEV0_CFG0,
 		      host->cfg0_raw & ~(7 << CW_PER_PAGE));
 	nandc_set_reg(chip, NAND_DEV0_CFG1, host->cfg1_raw);
@@ -1386,11 +1572,23 @@ static int read_id(struct qcom_nand_host *host, int column)
 {
 	struct nand_chip *chip = &host->chip;
 	struct qcom_nand_controller *nandc = get_qcom_nand_controller(chip);
+	u32 cmd = OP_FETCH_ID;
 
 	if (column == -1)
 		return 0;
 
-	nandc_set_reg(chip, NAND_FLASH_CMD, OP_FETCH_ID);
+	if (nandc->props->is_serial_nand) {
+		cmd |= (SPI_WP | SPI_HOLD | SPI_TRANSFER_MODE_x1);
+		/* For spi nand read 2-bytes id only
+		 * else if nandc->buf_count == 4; then the id value
+		 * will repeat and the SLC device will be detect as MLC.
+		 * by nand base layer
+		 * so overwrite the nandc->buf_count == 2;
+		 */
+		nandc->buf_count = 2;
+	}
+
+	nandc_set_reg(chip, NAND_FLASH_CMD, cmd);
 	nandc_set_reg(chip, NAND_ADDR0, column);
 	nandc_set_reg(chip, NAND_ADDR1, 0);
 	nandc_set_reg(chip, NAND_FLASH_CHIP_SELECT,
@@ -1410,8 +1608,13 @@ static int reset(struct qcom_nand_host *host)
 {
 	struct nand_chip *chip = &host->chip;
 	struct qcom_nand_controller *nandc = get_qcom_nand_controller(chip);
+	int cmd_rst;
 
-	nandc_set_reg(chip, NAND_FLASH_CMD, OP_RESET_DEVICE);
+	cmd_rst = OP_RESET_DEVICE;
+	if (nandc->props->is_serial_nand)
+		cmd_rst |= (SPI_WP | SPI_HOLD | SPI_TRANSFER_MODE_x1);
+
+	nandc_set_reg(chip, NAND_FLASH_CMD, cmd_rst);
 	nandc_set_reg(chip, NAND_EXEC_CMD, 1);
 
 	write_reg_dma(nandc, NAND_FLASH_CMD, 1, NAND_BAM_NEXT_SGL);
@@ -1450,6 +1653,13 @@ static int submit_descs(struct qcom_nand_controller *nandc)
 			if (r)
 				return r;
 		}
+		if (nandc->props->qpic_v2) {
+			if (bam_txn->sts_sgl_pos > bam_txn->sts_sgl_start) {
+				r = prepare_bam_async_desc(nandc, nandc->sts_chan, 0);
+				if (r)
+					return r;
+			}
+		}
 	}
 
 	list_for_each_entry(desc, &nandc->desc_list, node)
@@ -1467,6 +1677,8 @@ static int submit_descs(struct qcom_nand_controller *nandc)
 		dma_async_issue_pending(nandc->tx_chan);
 		dma_async_issue_pending(nandc->rx_chan);
 		dma_async_issue_pending(nandc->cmd_chan);
+		if (nandc->props->qpic_v2)
+			dma_async_issue_pending(nandc->sts_chan);
 
 		if (!wait_for_completion_timeout(&bam_txn->txn_done,
 						 QPIC_NAND_COMPLETION_TIMEOUT))
@@ -1981,6 +2193,8 @@ static int read_page_ecc(struct qcom_nand_host *host, u8 *data_buf,
 	struct nand_ecc_ctrl *ecc = &chip->ecc;
 	u8 *data_buf_start = data_buf, *oob_buf_start = oob_buf;
 	int i, ret;
+	__le32 *status_buf_start = nandc->status_buf;
+	__le32 *status_buf_cw = nandc->status_buf;
 
 	config_nand_page_read(chip);
 
@@ -2016,6 +2230,11 @@ static int read_page_ecc(struct qcom_nand_host *host, u8 *data_buf,
 			read_data_dma(nandc, FLASH_BUF_ACC, data_buf,
 				      data_size, 0);
 
+		if (nandc->props->qpic_v2 && nandc->props->page_scope) {
+			read_status_data_dma(nandc, FLASH_BUF_ACC, (void *)status_buf_cw,
+					MAX_STATUS_REG, 0);
+			status_buf_cw += (MAX_STATUS_REG / sizeof(u32));
+		}
 		/*
 		 * when ecc is enabled, the controller doesn't read the real
 		 * or dummy bad block markers in each chunk. To maintain a
@@ -2046,6 +2265,8 @@ static int read_page_ecc(struct qcom_nand_host *host, u8 *data_buf,
 		dev_err(nandc->dev, "failure to read page/oob\n");
 		return ret;
 	}
+	if (nandc->props->qpic_v2 && nandc->props->page_scope)
+		memmove(nandc->reg_read_buf, status_buf_start, nandc->sts_buf_size);
 
 	return parse_read_errors(host, data_buf_start, oob_buf_start, page);
 }
@@ -2697,6 +2918,8 @@ static int qcom_nand_attach_chip(struct nand_chip *chip)
 	int cwperpage, bad_block_byte, ret;
 	bool wide_bus;
 	int ecc_mode = 1;
+	int num_addr_cycle = 5, dsbl_sts_aftr_write = 0;
+	int wr_rd_bsy_gap = 2, recovery_cycle = 7;
 
 	/* controller only supports 512 bytes data steps */
 	ecc->size = NANDC_STEP_SIZE;
@@ -2811,33 +3034,43 @@ static int qcom_nand_attach_chip(struct nand_chip *chip)
 	host->cw_size = host->cw_data + ecc->bytes;
 	bad_block_byte = mtd->writesize - host->cw_size * (cwperpage - 1) + 1;
 
+	/* For QSPI serial nand QPIC config register value got changed
+	 * so configure the new value for qspi serial nand
+	 */
+	if (nandc->props->is_serial_nand) {
+		num_addr_cycle = 3;
+		dsbl_sts_aftr_write = 1;
+		wr_rd_bsy_gap = 20;
+		recovery_cycle = 0;
+	}
+
 	host->cfg0 = (cwperpage - 1) << CW_PER_PAGE
 				| host->cw_data << UD_SIZE_BYTES
-				| 0 << DISABLE_STATUS_AFTER_WRITE
-				| 5 << NUM_ADDR_CYCLES
+				| dsbl_sts_aftr_write << DISABLE_STATUS_AFTER_WRITE
+				| num_addr_cycle << NUM_ADDR_CYCLES
 				| host->ecc_bytes_hw << ECC_PARITY_SIZE_BYTES_RS
 				| 0 << STATUS_BFR_READ
 				| 1 << SET_RD_MODE_AFTER_STATUS
 				| host->spare_bytes << SPARE_SIZE_BYTES;
 
-	host->cfg1 = 7 << NAND_RECOVERY_CYCLES
+	host->cfg1 = recovery_cycle << NAND_RECOVERY_CYCLES
 				| 0 <<  CS_ACTIVE_BSY
 				| bad_block_byte << BAD_BLOCK_BYTE_NUM
 				| 0 << BAD_BLOCK_IN_SPARE_AREA
-				| 2 << WR_RD_BSY_GAP
+				| wr_rd_bsy_gap << WR_RD_BSY_GAP
 				| wide_bus << WIDE_FLASH
 				| host->bch_enabled << ENABLE_BCH_ECC;
 
 	host->cfg0_raw = (cwperpage - 1) << CW_PER_PAGE
 				| host->cw_size << UD_SIZE_BYTES
-				| 5 << NUM_ADDR_CYCLES
+				| num_addr_cycle << NUM_ADDR_CYCLES
 				| 0 << SPARE_SIZE_BYTES;
 
-	host->cfg1_raw = 7 << NAND_RECOVERY_CYCLES
+	host->cfg1_raw = recovery_cycle << NAND_RECOVERY_CYCLES
 				| 0 << CS_ACTIVE_BSY
 				| 17 << BAD_BLOCK_BYTE_NUM
 				| 1 << BAD_BLOCK_IN_SPARE_AREA
-				| 2 << WR_RD_BSY_GAP
+				| wr_rd_bsy_gap << WR_RD_BSY_GAP
 				| wide_bus << WIDE_FLASH
 				| 1 << DEV0_CFG1_ECC_DISABLE;
 
@@ -2888,6 +3121,11 @@ static void qcom_nandc_unalloc(struct qcom_nand_controller *nandc)
 
 		if (nandc->cmd_chan)
 			dma_release_channel(nandc->cmd_chan);
+		if (nandc->props->qpic_v2) {
+			if (nandc->sts_chan)
+				dma_release_channel(nandc->sts_chan);
+		}
+
 	} else {
 		if (nandc->chan)
 			dma_release_channel(nandc->chan);
@@ -2966,6 +3204,14 @@ static int qcom_nandc_alloc(struct qcom_nand_controller *nandc)
 			goto unalloc;
 		}
 
+		if (nandc->props->qpic_v2) {
+			nandc->sts_chan = dma_request_slave_channel(nandc->dev, "sts");
+			if (!nandc->sts_chan) {
+				dev_err(nandc->dev, "failed to request sts channel\n");
+				return -ENODEV;
+			}
+		}
+
 		/*
 		 * Initially allocate BAM transaction to read ONFI param page.
 		 * After detecting all the devices, this BAM transaction will
@@ -3042,6 +3288,580 @@ static int qcom_nandc_setup(struct qcom_nand_controller *nandc)
 	return 0;
 }
 
+static void qspi_write_reg_bam(struct nand_chip *chip,
+		unsigned int val, unsigned int reg)
+{
+	struct qcom_nand_controller *nandc = get_qcom_nand_controller(chip);
+	int ret;
+	clear_bam_transaction(nandc);
+	nandc_set_reg(chip, reg, val);
+	write_reg_dma(nandc, reg, 1, NAND_BAM_NEXT_SGL);
+
+	ret = submit_descs(nandc);
+	if (ret)
+		dev_err(nandc->dev, "Error in submitting descriptor to write reg %x\n", reg);
+	free_descs(nandc);
+}
+
+static void qspi_nand_init(struct nand_chip *chip)
+{
+	struct qcom_nand_controller *nandc = get_qcom_nand_controller(chip);
+	u32 spi_cfg_val = 0x0;
+	u32 reg = 0x0;
+
+	spi_cfg_val |= (LOAD_CLK_CNTR_INIT_EN | (CLK_CNTR_INIT_VAL_VEC << 16)
+			| (FEA_STATUS_DEV_ADDR << 8) | SPI_CFG);
+
+	qspi_write_reg_bam(chip, 0x0, NAND_FLASH_SPI_CFG);
+	qspi_write_reg_bam(chip, spi_cfg_val, NAND_FLASH_SPI_CFG);
+	spi_cfg_val &= ~LOAD_CLK_CNTR_INIT_EN;
+	qspi_write_reg_bam(chip, spi_cfg_val, NAND_FLASH_SPI_CFG);
+
+	reg = dev_cmd_reg_addr(nandc, NAND_DEV_CMD0);
+	nandc_write(nandc, reg, CMD0_VAL);
+	nandc_write(nandc, reg + 4, CMD1_VAL);
+	nandc_write(nandc, reg + 8, CMD2_VAL);
+	nandc_write(nandc, reg + 12, CMD_VLD_VAL);
+	nandc_write(nandc, reg + 16, CMD7_VAL);
+	reg = dev_cmd_reg_addr(nandc, NAND_DEV_CMD3);
+	nandc_write(nandc, reg, CMD3_VAL);
+
+	qspi_write_reg_bam(chip, SPI_NUM_ADDR, NAND_SPI_NUM_ADDR_CYCLES);
+	qspi_write_reg_bam(chip, WAIT_CNT, NAND_SPI_BUSY_CHECK_WAIT_CNT);
+}
+
+static void qspi_set_phase(struct qcom_nand_controller *nandc,
+		struct qcom_nand_host *host, int phase)
+{
+	struct nand_chip *chip = &host->chip;
+	u32 qspi_cfg_val = 0x0;
+	int reg = dev_cmd_reg_addr(nandc, NAND_FLASH_SPI_CFG);
+
+	qspi_cfg_val = nandc_read(nandc, reg);
+	qspi_cfg_val |= LOAD_CLK_CNTR_INIT_EN;
+
+	qspi_write_reg_bam(chip, qspi_cfg_val, NAND_FLASH_SPI_CFG);
+	qspi_cfg_val &= 0xf000ffff;
+
+	/* Write phase value for all the lines */
+	qspi_cfg_val |= ((phase << 16) | (phase << 19) | (phase << 22)
+			| (phase << 25));
+	qspi_write_reg_bam(chip, qspi_cfg_val, NAND_FLASH_SPI_CFG);
+
+	/* Clear LOAD_CLK_CNTR_INIT_EN bit to load phase value */
+	qspi_cfg_val &= ~LOAD_CLK_CNTR_INIT_EN;
+	qspi_write_reg_bam(chip, qspi_cfg_val, NAND_FLASH_SPI_CFG);
+}
+
+static int qspi_get_appropriate_phase(struct qcom_nand_controller *nandc, u8 *phase_table,
+		int phase_count)
+{
+	int i, cnt = 0, phase = 0x0;
+	u8 phase_ranges[TOTAL_NUM_PHASE] = {'\0'};
+
+	for (i = 0; i < phase_count; i++) {
+		if ((phase_table[i] + 1 == phase_table[i + 1]) &&
+		(phase_table[i + 1] + 1 == phase_table[i + 2]))
+			phase_ranges[cnt++] = phase_table[i + 1];
+	}
+
+	/* Filter out middle phase */
+	if (cnt > 1 && cnt <= TOTAL_NUM_PHASE) {
+		if (!(cnt & 1))
+			phase = phase_ranges[cnt/2 - 1];
+		else
+			phase = phase_ranges[cnt/2];
+	}
+
+	return phase;
+}
+
+static int qpic_serial_check_status(__le32 *status)
+{
+	u32 flash  = le32_to_cpu(*(__le32 *)status);
+
+	if (flash & FLASH_ERROR) {
+		if (flash & FS_MPU_ERR)
+			return -EPERM;
+		if (flash & FS_TIMEOUT_ERR)
+			return -ETIMEDOUT;
+		if (flash & FS_OP_ERR)
+			return -EIO;
+	}
+	return 0;
+}
+
+static void qcom_check_quad_mode(struct mtd_info *mtd, struct qcom_nand_host *host)
+{
+	int i, ret;
+	struct nand_chip *chip = mtd_to_nand(mtd);
+	struct qcom_nand_controller *nandc = get_qcom_nand_controller(chip);
+	unsigned int command = NAND_CMD_READID_SERIAL;
+	u8 id_data[3];
+	u32 cmd3_val;
+
+	pre_command(host, command);
+
+	/* get the device id from device */
+	nandc->buf_count = 4;
+	read_id(host, 0x00);
+
+	ret = submit_descs(nandc);
+	if (ret)
+		dev_err(nandc->dev,
+				"failure submitting descs for command %d\n",
+				command);
+	free_descs(nandc);
+
+	post_command(host, command);
+
+	/* Read Id bytes */
+	for (i = 0; i < 3; i++)
+		id_data[i] = chip->legacy.read_byte(chip);
+	if (id_data[0] == SPI_FLASH_MICRON_ID) {
+		cmd3_val = CMD3_VAL & CMD3_MASK;
+		host->check_qe_bit = false;
+		nandc_write(nandc, dev_cmd_reg_addr(nandc, NAND_DEV_CMD3), cmd3_val);
+	} else if (id_data[0] == SPI_FLASH_GIGA_ID &&
+			id_data[1] == SPI_FLASH_ESMT_DEVICE_ID) {
+	       host->check_qe_bit = false;
+	} else if (id_data[0] == SPI_FLASH_WINBOND_ID &&
+			id_data[1] == SPI_WINBOND_DEVICE_1) {
+	       host->check_qe_bit = false;
+	} else
+		host->check_qe_bit = true;
+}
+
+static int qcom_serial_get_feature(struct qcom_nand_controller *nandc,
+		struct qcom_nand_host *host, u32 faddr)
+{
+	struct nand_chip *chip = &host->chip;
+	u32 cmd_val = 0x0;
+	u32 command = NAND_CMD_GET_FEATURE_SERIAL;
+	int ret;
+
+	/* Clear the BAM transaction index */
+	clear_bam_transaction(nandc);
+
+	cmd_val = (SPI_TRANSFER_MODE_x1 | SPI_WP | SPI_HOLD |
+			ACC_FEATURE);
+
+	pre_command(host, command);
+
+	nandc_set_reg(chip, NAND_FLASH_CMD, cmd_val);
+	nandc_set_reg(chip, NAND_ADDR0, faddr);
+	nandc_set_reg(chip, NAND_ADDR1, 0);
+
+	/* Clear the feature register value to get correct feature value */
+	nandc_set_reg(chip, NAND_FLASH_FEATURES, 0);
+
+	nandc_set_reg(chip, NAND_EXEC_CMD, 1);
+
+	write_reg_dma(nandc, NAND_FLASH_CMD, 3, NAND_BAM_NEXT_SGL);
+
+	write_reg_dma(nandc, NAND_FLASH_FEATURES, 1, NAND_BAM_NEXT_SGL);
+
+	write_reg_dma(nandc, NAND_EXEC_CMD, 1, NAND_BAM_NEXT_SGL);
+
+	read_reg_dma(nandc, NAND_FLASH_FEATURES, 1, NAND_BAM_NEXT_SGL);
+	/* submit the descriptor to bam for execution*/
+	ret = submit_descs(nandc);
+	free_descs(nandc);
+	if (ret) {
+		dev_err(nandc->dev, "Error in submitting descriptor for command:%d\n",
+				command);
+		return ret;
+	}
+
+	nandc_read_buffer_sync(nandc, true);
+
+	/* read_reg_dma will read data in to nandc->reg_read_buf
+	 * so after issueing command in read_reg_dma function read reg_read_buf
+	 * buffer
+	 */
+	ret = le32_to_cpu(*(__le32 *)nandc->reg_read_buf);
+
+	return ret;
+}
+
+static int qcom_serial_set_feature(struct qcom_nand_controller *nandc,
+		struct qcom_nand_host *host, u32 faddr, u32 fval)
+{
+	struct nand_chip *chip = &host->chip;
+	int ret;
+	u32 command = NAND_CMD_SET_FEATURE_SERIAL;
+	u32 cmd_val = (SPI_TRANSFER_MODE_x1 | SPI_WP | SPI_HOLD |
+			ACC_FEATURE | QPIC_SET_FEATURE);
+
+	/* Clear the BAM transaction index */
+	clear_bam_transaction(nandc);
+
+	pre_command(host, command);
+
+	nandc_set_reg(chip, NAND_FLASH_CMD, cmd_val);
+	nandc_set_reg(chip, NAND_ADDR0, faddr);
+	nandc_set_reg(chip, NAND_ADDR1, 0);
+	nandc_set_reg(chip, NAND_FLASH_FEATURES, fval);
+
+	nandc_set_reg(chip, NAND_EXEC_CMD, 1);
+
+	write_reg_dma(nandc, NAND_FLASH_CMD, 3, NAND_BAM_NEXT_SGL);
+
+	write_reg_dma(nandc, NAND_FLASH_FEATURES, 1, NAND_BAM_NEXT_SGL);
+
+	write_reg_dma(nandc, NAND_EXEC_CMD, 1, NAND_BAM_NEXT_SGL);
+
+	read_reg_dma(nandc, NAND_FLASH_STATUS, 1, NAND_BAM_NEXT_SGL);
+
+	/* submit the descriptor to bam for execution*/
+	ret = submit_descs(nandc);
+	free_descs(nandc);
+	if (ret) {
+		dev_err(nandc->dev, "Error in submitting descriptor for command:%d\n",
+				command);
+		return ret;
+	}
+
+	/* read_reg_dma will read data in to nandc->reg_read_buf
+	 * so after issueing command in read_reg_dma function read reg_read_buf
+	 * buffer
+	 */
+	nandc_read_buffer_sync(nandc, true);
+
+	ret = qpic_serial_check_status(nandc->reg_read_buf);
+	if (ret) {
+		dev_err(nandc->dev, "Error in executing command:%d\n",command);
+		return ret;
+	}
+	return ret;
+}
+
+
+static bool config_buf_bit(struct mtd_info *mtd, struct qcom_nand_host *host, u8 *pos)
+{
+	int i, ret;
+	struct nand_chip *chip = mtd_to_nand(mtd);
+	struct qcom_nand_controller *nandc = get_qcom_nand_controller(chip);
+	unsigned int command = NAND_CMD_READID_SERIAL;
+	u8 id_data[3];
+
+	pre_command(host, command);
+
+	/* get the device id from device */
+	nandc->buf_count = 4;
+	read_id(host, 0x00);
+
+	ret = submit_descs(nandc);
+	if (ret)
+		dev_err(nandc->dev, "failure submitting descs for command %d\n",
+				command);
+	free_descs(nandc);
+
+	post_command(host, command);
+
+	/* Read Id bytes */
+	for (i = 0; i < 2; i++)
+		id_data[i] = chip->legacy.read_byte(chip);
+/* Add device ID here if SPI Nand supports BUF_BIT to configure */
+	switch (id_data[0]) {
+	case SPI_FLASH_WINBOND_ID:
+		*pos = 3;
+		return true;
+	default:
+		return false;
+	}
+}
+
+static int qspi_nand_device_config(struct qcom_nand_controller *nandc,
+				   struct qcom_nand_host *host, struct mtd_info *mtd)
+{
+	int status = 0;
+	u8 buf_bit_pos = 0;
+	nandc->buf_count = 4;
+	memset(nandc->reg_read_buf, 0x0, nandc->buf_count);
+	/* Configure BUF bit for SPI Nand device
+	 * Read the id and compare for device id
+	 */
+	if (config_buf_bit(mtd, host, &buf_bit_pos)) {
+		status = qcom_serial_get_feature(nandc, host, SPI_FLASH_FEATURE_REG);
+		if (status < 0) {
+			dev_err(nandc->dev,"Error in getting feature Continous buff");
+			return status;
+		}
+
+		if (!((status >> 8) & SPI_NAND_BUF_BIT(buf_bit_pos))) {
+			dev_dbg(nandc->dev, "Continous buffer mode not enabled on power on\n");
+			dev_dbg(nandc->dev, "Issuing set feature command enbale it\n");
+			status = qcom_serial_set_feature(nandc, host, SPI_FLASH_FEATURE_REG,
+					SPI_NAND_BUF_BIT(buf_bit_pos) | (status >> 8));
+			if (status < 0) {
+				dev_err(nandc->dev,"Error in setting feature Quad mode.");
+				return status;
+			}
+		} else {
+			dev_dbg(nandc->dev, "Continous buffer mode enabled on power on\n");
+		}
+	}
+
+	qcom_check_quad_mode(mtd, host);
+
+	if (!host->check_qe_bit) {
+		host->quad_mode = true;
+		return 0;
+	}
+
+	if (nandc->props->quad_mode) {
+		/* Check if device supports x4 Mode and enable it if not enabled*/
+		status = qcom_serial_get_feature(nandc, host,
+							SPI_FLASH_FEATURE_REG);
+		if (status < 0) {
+			dev_err(nandc->dev, "Error in getting feature x4 mode\n");
+			return status;
+		}
+
+		if (!((status >> 8) & SPI_FLASH_QUAD_MODE)) {
+			/* If x4 mode bit not enabled issue set feature command
+			 * to enable quad mode bit of flash device.
+			 */
+			status = qcom_serial_set_feature(nandc, host,
+							SPI_FLASH_FEATURE_REG,
+							SPI_FLASH_QUAD_MODE);
+			if (status < 0) {
+				dev_err(nandc->dev, "Error in setting feature x4 mode\n");
+				return status;
+			}
+			/* again issue the get feature command to check if quad
+			 * mode is enabled or not
+			 */
+			status = qcom_serial_get_feature(nandc, host,
+							SPI_FLASH_FEATURE_REG);
+			if (status < 0) {
+				dev_err(nandc->dev, "Error in getting feature x4 mode\n");
+				return status;
+			}
+
+			if ((status >> 8) & SPI_FLASH_QUAD_MODE) {
+				host->quad_mode = true;
+				dev_info(nandc->dev, "x4 mode enabled successfully\n");
+			} else {
+				host->quad_mode = false;
+				dev_err(nandc->dev, "x4 mode not enabled, using x1 mode\n");
+				return 0;
+			}
+		} else {
+			dev_info(nandc->dev, "x4 mode enabled already remotely\n");
+			host->quad_mode = true;
+		}
+	}
+	return 0;
+}
+
+static int qspi_execute_training(struct qcom_nand_controller *nandc,
+		struct qcom_nand_host *host, struct mtd_info *mtd)
+{
+	u32 pages_per_block = 0, page = 0;
+	int ret = 0, bb_cnt = 0, i, phase_failed = 0;
+	int phase_cnt, phase;
+	u32 training_offset = 0;
+	u8 *training_data = NULL, trained_phase[TOTAL_NUM_PHASE] = {'\0'};
+	struct nand_chip *chip = &host->chip;
+	int reg;
+
+	u32 max_iomacro_clk = 0;
+	struct device_node *np = nandc->dev->of_node;
+	int sz;
+	u32 *arr = NULL;
+	u32 len = 0;
+
+	/* Set feedback clk enable bit to do auto adjustment of phase
+	 * at lower frequency
+	 */
+	reg = dev_cmd_reg_addr(nandc, NAND_QSPI_MSTR_CONFIG);
+	qspi_write_reg_bam(chip, (nandc_read(nandc,
+			reg) | FEEDBACK_CLK_EN),
+			NAND_QSPI_MSTR_CONFIG);
+
+	/* Read the training offset patched from u-boot */
+	if (of_property_read_u32(np, "qcom,training_offset",
+				&training_offset)) {
+		dev_err(nandc->dev, "Serial training partition not found");
+		ret = -EINVAL;
+		goto trng_err;
+	}
+
+	pages_per_block = 1 << (chip->phys_erase_shift - chip->page_shift);
+	page = (training_offset >> chip->page_shift) & chip->pagemask;
+
+	/* check for bad block in allocated training blocks
+	 * The training blocks should be continuous good block or
+	 * continuous bad block, it should be not like good,bad,good etc.
+	 * avoid to use this type of block for serial training
+	 */
+	while(qcom_nandc_block_bad(chip, training_offset) && bb_cnt < MAX_TRAINING_BLK) {
+		training_offset += mtd->erasesize;
+		page += pages_per_block;
+		bb_cnt++;
+	}
+
+	if (bb_cnt == MAX_TRAINING_BLK) {
+		dev_dbg(nandc->dev, "All training blocks are bad, skipping serial training");
+		dev_dbg(nandc->dev, "Operatig at lower frequency");
+		ret = -EINVAL;
+		goto trng_err;
+	}
+
+	qcom_nandc_command(chip, NAND_CMD_ERASE1, 0, page);
+
+	/* Allocate memory to hold one NAND page */
+	training_data = kzalloc(mtd->writesize, GFP_KERNEL);
+	if (!training_data) {
+		dev_err(nandc->dev, "Error in allocating memory");
+		ret = -ENOMEM;
+		goto trng_err;
+	}
+	memset(training_data, '\0', mtd->writesize);
+
+	for (i = 0; i < mtd->writesize; i += sizeof(qspi_training_block_64))
+		memcpy(training_data + i, qspi_training_block_64,
+			sizeof(qspi_training_block_64));
+
+	/* Write qspi training data to flash */
+	ret = qcom_nandc_write_page(chip, training_data, 0, page);
+	if (ret) {
+		dev_err(nandc->dev, "Error in writing training data");
+		ret = -EINVAL;
+		goto mem_err;
+	}
+
+	/* Read qspi training data @ low freq */
+	memset(training_data, 0xff, mtd->writesize);
+	ret = qcom_nandc_read_page(chip, training_data, 0, page);
+	if (ret < 0) {
+		dev_err(nandc->dev, "Error in reading training data @ low freq");
+		ret = -EINVAL;
+		goto mem_err;
+	}
+
+	/* compare read training data with known pattern */
+	for (i = 0; i <  mtd->writesize; i += sizeof(qspi_training_block_64)) {
+		if (memcmp(training_data + i, qspi_training_block_64,
+				sizeof(qspi_training_block_64))) {
+			dev_err(nandc->dev, "Training data mismatch @ low freq");
+			ret = -EINVAL;
+			goto mem_err;
+		}
+	}
+
+	/* clear feedback clock bit and start training here */
+	qspi_write_reg_bam(chip, (nandc_read(nandc,
+			reg) & ~FEEDBACK_CLK_EN),
+			NAND_QSPI_MSTR_CONFIG);
+
+	/* Get max io macro clock from device tree, value should be
+	 * 200 MHz, 380 MHz, 400 MHz etc.
+	 * */
+	if (of_property_read_u32(np, "qcom,io_macro_max_clk",
+				&max_iomacro_clk)) {
+		dev_err(nandc->dev, "Error in reading max io macro clock from dts");
+		goto mem_err;
+	}
+
+	/* Read all supported io_macro clock frequency from dts */
+	if (!of_get_property(np, "qcom,io_macro_clk_rates", &len)) {
+		dev_err(nandc->dev, "Error in reading length of io_macro_clock\n");
+		goto mem_err;
+	}
+
+	sz = (len / sizeof(*arr));
+
+	arr = kzalloc(sz * sizeof(*arr), GFP_KERNEL);
+	if (!arr) {
+		dev_err(nandc->dev, "failed allocating memory for qcom,io_macro_clk_rates\n");
+		goto mem_err;
+	}
+
+	ret = of_property_read_u32_array(np, "qcom,io_macro_clk_rates", arr, sz);
+	if (ret < 0) {
+		dev_err(nandc->dev, "failed reading array qcom,io_macro_clk_rates %d\n", ret);
+		goto mem_err;
+	}
+
+	sz -= 1;
+
+iomacro_set_clk:
+	ret =  clk_set_rate(nandc->iomacro_clk, max_iomacro_clk);
+	if (ret) {
+		dev_err(nandc->dev,"Setting clk rate to %d MHz failed", max_iomacro_clk);
+		goto mem_err;
+	}
+
+	phase = 1;
+	phase_cnt = 0;
+
+	do {
+		qspi_set_phase(nandc, host, phase);
+
+		/* Prepare clean buffer to read */
+		memset(training_data, 0xff, mtd->writesize);
+		ret = qcom_nandc_read_page(chip, training_data, 0, page);
+		if (ret < 0) {
+			dev_err(nandc->dev, "Error in reading training page at %d MHz",
+					max_iomacro_clk);
+			/* Fall back to next lower clock */
+			if (sz < 0)
+				goto default_freq;
+			max_iomacro_clk = arr[--sz];
+			goto iomacro_set_clk;
+		}
+		/* compare read training data with known pattern */
+		for (i = 0; i <  mtd->writesize; i += sizeof(qspi_training_block_64)) {
+			if (memcmp(training_data + i, qspi_training_block_64,
+					sizeof(qspi_training_block_64))) {
+				phase_failed++;
+				break;
+			}
+		}
+
+		if (i == mtd->writesize)
+			trained_phase[phase_cnt++] = phase;
+
+	} while (phase++ < TOTAL_NUM_PHASE);
+
+	if (phase_cnt) {
+		phase = qspi_get_appropriate_phase(nandc, trained_phase, phase_cnt);
+		if (phase == 0) {
+			dev_err(nandc->dev, "No continous three phase found at %d MHz",
+					max_iomacro_clk);
+			if (sz < 0)
+				goto default_freq;
+			max_iomacro_clk = arr[--sz];
+			goto iomacro_set_clk;
+		}
+		qspi_set_phase(nandc, host, phase);
+	} else {
+default_freq:
+		dev_err(nandc->dev,"Serial training failed");
+		dev_err(nandc->dev, "Running @ low freq 50MHz");
+		/* Run @ lower frequency 50Mhz with feedback clk bit enabled  */
+		qspi_write_reg_bam(chip, (nandc_read(nandc,
+			reg) | FEEDBACK_CLK_EN),
+			NAND_QSPI_MSTR_CONFIG);
+		ret =  clk_set_rate(nandc->iomacro_clk, IO_MACRO_50_MHZ);
+		if (ret) {
+			dev_err(nandc->dev,"Setting clk rate to 50000000 MHz failed");
+			goto mem_err;
+		}
+	}
+
+mem_err:
+	kfree(training_data);
+trng_err:
+	if (arr)
+		kfree(arr);
+	return ret;
+}
+
+
 static const char * const probes[] = { "cmdlinepart", "ofpart", "qcomsmem", NULL };
 
 static int qcom_nand_host_parse_boot_partitions(struct qcom_nand_controller *nandc,
@@ -3161,10 +3981,39 @@ static int qcom_nand_host_init_and_register(struct qcom_nand_controller *nandc,
 	/* set up initial status value */
 	host->status = NAND_STATUS_READY | NAND_STATUS_WP;
 
+	if (nandc->props->is_serial_nand)
+		qspi_nand_init(chip);
+
 	ret = nand_scan(chip, 1);
 	if (ret)
 		return ret;
 
+	if (nandc->props->qpic_v2 && nandc->props->page_scope) {
+		nandc->sts_buf_size = (mtd->writesize / NANDC_STEP_SIZE) *
+							MAX_STATUS_REG;
+		nandc->status_buf = devm_kzalloc(nandc->dev, nandc->sts_buf_size,
+				GFP_KERNEL);
+		if (!nandc->status_buf)
+			return -ENOMEM;
+	}
+
+	/* QSPI serial training is required if io_macro clk frequency
+	 * is more than 50MHz. This is due to different PNR and PCB delays,
+	 * serial read data can come with different delays to QPIC. So
+	 * Rx clock should be adjusted according to delays so that Rx Data
+	 * can be captured correctly.
+	 */
+	if (nandc->props->is_serial_nand) {
+		ret = qspi_nand_device_config(nandc, host, mtd);
+		if (ret)
+			dev_err(nandc->dev, "qspi_nand device config failed\n");
+		if (nandc->props->is_serial_training) {
+			ret = qspi_execute_training(nandc, host, mtd);
+			if (ret)
+				dev_err(nandc->dev, "failed to enable serial training\n");
+		}
+	}
+
 	ret = mtd_device_parse_register(mtd, probes, NULL, NULL, 0);
 	if (ret)
 		goto err;
@@ -3265,6 +4114,16 @@ static int qcom_nandc_probe(struct platform_device *pdev)
 	if (IS_ERR(nandc->aon_clk))
 		return PTR_ERR(nandc->aon_clk);
 
+	if (nandc->props->is_serial_nand) {
+		nandc->iomacro_clk = devm_clk_get(dev, "io_macro");
+		if (IS_ERR(nandc->iomacro_clk))
+			return PTR_ERR(nandc->iomacro_clk);
+
+		ret =  clk_set_rate(nandc->iomacro_clk, 200000000);
+		if (ret)
+			return ret;
+	}
+
 	ret = qcom_nandc_parse_dt(pdev);
 	if (ret)
 		return ret;
@@ -3289,6 +4148,12 @@ static int qcom_nandc_probe(struct platform_device *pdev)
 	if (ret)
 		goto err_aon_clk;
 
+	if (nandc->props->is_serial_nand) {
+		ret = clk_prepare_enable(nandc->iomacro_clk);
+		if (ret)
+			goto err_setup;
+	}
+
 	ret = qcom_nandc_alloc(nandc);
 	if (ret)
 		goto err_nandc_alloc;
@@ -3370,6 +4235,17 @@ static const struct qcom_nandc_props sdx55_nandc_props = {
 	.dev_cmd_reg_start = 0x7000,
 };
 
+static const struct qcom_nandc_props ipq9574_nandc_props = {
+	.ecc_modes = (ECC_BCH_4BIT | ECC_BCH_8BIT),
+	.is_bam = true,
+	.is_serial_nand = true,
+	.qpic_v2 = true,
+	.is_serial_training = true,
+	.quad_mode = true,
+	.page_scope = true,
+	.dev_cmd_reg_start = 0x7000,
+};
+
 /*
  * data will hold a struct pointer containing more differences once we support
  * more controller variants
@@ -3391,6 +4267,10 @@ static const struct of_device_id qcom_nandc_of_match[] = {
 		.compatible = "qcom,ipq8074-nand",
 		.data = &ipq8074_nandc_props,
 	},
+	{
+		.compatible = "qcom,ipq9574-nand",
+		.data = &ipq9574_nandc_props,
+	},
 	{
 		.compatible = "qcom,sdx55-nand",
 		.data = &sdx55_nandc_props,
-- 
2.17.1

